/*************************************************************************
 *
 *  Copyright (c) 2023 Rajit Manohar
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor,
 *  Boston, MA  02110-1301, USA.
 *
 **************************************************************************
 */
#include "synth.h"
#include <common/config.h>
#include <common/misc.h>
#include <act/passes.h>


/*
  To synthesize a design, we need to do a few things:

  - all data types must be implemented with bools
    => structures must be implemented 
    => int and bools must be implemented
    => channels must be implemented
  
  - the implementation must override already defined variables
  - the implementation must intantiate any fresh variables


  Convention:

     prefix_<name> is used to implement <name>, where <name> is the
     *expanded* version of the original type.

     The implementation begins by importing the original file.

     
*/

ActSynthesize::ActSynthesize (const char *prefix, char *infile, char *outfile, char *exprfile)
{
  const char *expr_file;
  
  if (outfile) {
    _out = fopen (outfile, "w");
    if (!_out) {
      fatal_error ("Could not open file `%s' for writing", outfile);
    }
  }
  else {
    _out = stdout;
  }

  if (config_exists ("act.output_window")) {
    _pp = pp_init (_out, config_get_int ("act.output_window"));
  }
  else {
    _pp = pp_init (_out, 78);
  }

  if (exprfile) {
    expr_file = exprfile;
  }
  else {
    expr_file = "expr.act";
  }

  _expr = fopen (expr_file, "w");
  if (!_expr) {
    fatal_error ("Could not open file `%s' for writing", expr_file);
  }

  pp_printf_raw (_pp, "/* auto-generated by logic synthesis */\n");
  pp_printf_raw (_pp, "import \"%s\";\n", outfile);
  pp_printf_raw (_pp, "import \"%s\";\n", expr_file);
  pp_forced (_pp, 0);

  _top = NULL;
}


void ActSynthesize::Close ()
{
  if (_pp) {
    pp_close (_pp);
    _pp = NULL;
  }
  if (_out) {
    if (_out != stdout) {
      fclose (_out);
      _out = NULL;
    }
  }
  if (_expr) {
    fclose (_expr);
    _expr = NULL;
  }
}

ActSynthesize::~ActSynthesize ()
{
  Close ();
}


bool ActSynthesize::runSynthesis (Process *p)
{
  if (!p) {
    return false;
  }

  if (!p->isExpanded()) {
    if (!ActNamespace::Global()->isExpanded()) {
      ActNamespace::Act()->Expand ();
    }
    p = p->Expand (ActNamespace::Global(), p->CurScope (), 0, NULL);
  }
  _top = p;


  /*-- Apply standard decompositions --*/
  
  ActCHPFuncInline *ip = new ActCHPFuncInline (ActNamespace::Act());
  ip->run (p);

  ActCHPMemory *mem = new ActCHPMemory (ActNamespace::Act());
  mem->run (p);

  ActCHPArbiter *arbp = new ActCHPArbiter (ActNamespace::Act());
  arbp->run (p);

  /*-- Emit any additional imports needed --*/
  emitTopImports ();

  /*-- Refine all structures --*/

  // We need to call synthesis-specific functions here

  /*-- Run core synthesis steps --*/

  // Dynamic pass infrastructure to call this.


  /*-- Close output files --*/
  Close ();
  
  return true;
}
