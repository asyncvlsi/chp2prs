/* auto-generated by logic synthesis */
import "4.act";

import syn::ring;
open syn::ring;
open syn;
import "runs/4_expr.act";
open syn::expr;


defproc ring_snk <: snk()
+{
  bd_int<8> x;
  bd<8> l;
  }
{
  refine {
    /* synthesis output */
    
/* start rsyn */
// One Ring ---------------------

// Initial token buffer to initialize ring
elem_c_itb block_1;

// Pipe block for action: l?x
elem_c_ppa_brs_bd block_2;
connect_inchan_to_ctrl<8> conn_z_2;
conn_z_2.ctrl = block_2.zero;
conn_z_2.ch = l;

// Data for action: l?x
capture<5,6,8> latch_x_0;
latch_x_0.go = block_2.data;
latch_x_0.din = l.d;

// Connecting block_1 & block_2
block_2.m1 = block_1.p1;

// Connecting block_2 & block_1
block_1.m1 = block_2.p1;


/* end rsyn */
    
    /* end refine */
  }
  /* end process */
}
defproc ring_src <: src()
+{
  bd<8> r;
  }
{
  refine {
    /* synthesis output */
    
/* start rsyn */

// Pipe block for action: r!0x5
elem_c_paa_brs_bd block_1;
connect_outchan_to_ctrl<8> conn_z_1;
conn_z_1.ch = r;

// Data for action: r!0x5
// output bitwidth: 8 bits


blk_1 inst_1;
delay_line_chan<1> delay_expr_1;
inst_1.out = r.d;
delay_expr_1.m1 = block_1.zero;
delay_expr_1.p1 = conn_z_1.ctrl;
source_brs term_inst_1;
term_inst_1.c = block_1.m1;
sink_brs term_inst_2;
term_inst_2.c = block_1.p1;


/* end rsyn */
    
    /* end refine */
  }
  /* end process */
}
defproc ring_src_c <: src_c()
+{
  bd<1> r;
  }
{
  refine {
    /* synthesis output */
    
/* start rsyn */

// Pipe block for action: r!0x0
elem_c_paa_brs_bd block_1;
connect_outchan_to_ctrl<1> conn_z_1;
conn_z_1.ch = r;

// Data for action: r!0x0
// output bitwidth: 1 bits


blk_2 inst_2;
delay_line_chan<1> delay_expr_2;
inst_2.out = r.d;
delay_expr_2.m1 = block_1.zero;
delay_expr_2.p1 = conn_z_1.ctrl;
source_brs term_inst_1;
term_inst_1.c = block_1.m1;
sink_brs term_inst_2;
term_inst_2.c = block_1.p1;


/* end rsyn */
    
    /* end refine */
  }
  /* end process */
}
defproc ring_split <: split()
+{
  bd_int<8> x;
  bd_int<1> c;
  bd<8> r2;
  bd<8> r1;
  bd<8> l2;
  bd<1> l1;
  }
{
  refine {
    /* synthesis output */
    
/* start rsyn */
// Branched Ring ----------------

// Initial token buffer to initialize ring
elem_c_itb block_1;

// Pipe block for action: l1?c
elem_c_ppa_brs_bd block_2;
connect_inchan_to_ctrl<1> conn_z_2;
conn_z_2.ctrl = block_2.zero;
conn_z_2.ch = l1;

// Data for action: l1?c
capture<5,6,1> latch_c_0;
latch_c_0.go = block_2.data;
latch_c_0.din = l1.d;

// Connecting block_1 & block_2
block_2.m1 = block_1.p1;

// Pipe block for action: l2?x
elem_c_ppa_brs_bd block_3;
connect_inchan_to_ctrl<8> conn_z_3;
conn_z_3.ctrl = block_3.zero;
conn_z_3.ch = l2;

// Data for action: l2?x
capture<5,6,8> latch_x_0;
latch_x_0.go = block_3.data;
latch_x_0.din = l2.d;

// Connecting block_2 & block_3
block_3.m1 = block_2.p1;

// 2-way selection split for : [c=0x0 -> r1!x [] c=0x1 -> r2!x]
// 2-way selection merge 
selection_split<2> block_4;
selection_merge<2> block_5;


// typical delay: 21.72ps
blk_3 inst_3;
inst_3.in_1 = latch_c_0.dout;
block_4.gs[0] = inst_3.out[0];
gp_connect block_6;

// Connecting selection split block_4 (output) & pipe block_6
block_4.co[0] = block_6.m1;


// typical delay: 66.42ps
blk_4 inst_4;
inst_4.in_2 = latch_c_0.dout;
block_4.gs[1] = inst_4.out[0];
gp_connect block_7;

// Connecting selection split block_4 (output) & pipe block_7
block_4.co[1] = block_7.m1;

// Pipe block for action: r1!x
elem_c_paa_brs_bd block_8;
connect_outchan_to_ctrl<8> conn_z_8;
conn_z_8.ch = r1;

// Data for action: r1!x
conn_z_8.ctrl = block_8.zero;

latch_x_0.dout = r1.d;

// Connecting block_6 & block_8
block_8.m1 = block_6.p1;

// Connecting selection merge block_5 (input) & pipe block_8
block_5.ci[0] = block_8.p1;

// Pipe block for action: r2!x
elem_c_paa_brs_bd block_9;
connect_outchan_to_ctrl<8> conn_z_9;
conn_z_9.ch = r2;

// Data for action: r2!x
conn_z_9.ctrl = block_9.zero;

latch_x_0.dout = r2.d;

// Connecting block_7 & block_9
block_9.m1 = block_7.p1;

// Connecting selection merge block_5 (input) & pipe block_9
block_5.ci[1] = block_9.p1;

// Delaying pre-split-block sync. by max. delay of all guard evaluators
delay_line_chan<2> delay_select_4;
delay_select_4.m1 = block_3.p1;
delay_select_4.p1 = block_4.m1;

// Connecting block_5 & block_1
block_1.m1 = block_5.p1;


/* end rsyn */
    
    /* end refine */
  }
  /* end process */
}
defproc ring_testproc <: testproc()
+{
  ring_snk o2;
  ring_snk o1;
  ring_src ix;
  ring_src_c ic;
  bd<8> Y1;
  bd<8> X;
  bd<1> C;
  ring_split s;
  bd<8> Y2;
  }
{
  /* end process */
}
