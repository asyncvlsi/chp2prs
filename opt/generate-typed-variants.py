import itertools
import os

# This provides support for typesafe enumerations
# which are indexed by an enum class. There has to be a "correct"
# way to do this using templates, but I couldnt figure that out, so
# instead we generate the code for variants with a few limited sizes

with open("typed-variants.h", "w") as out:
    out.write("#pragma once\n")
    out.write("// THIS FILE IS GENERATED BY generate-enum-typed-variants.py. DO NOT EDIT\n")
    out.write("#include <utility> // for std::move\n")
#    out.write("#include \"utils/hassert.h\"\n")
    out.write("#include \"hassert.h\"\n")
    out.write("namespace ChpOptimize {\n")
    for N in range(2, 25):
        out.write("template<class T, {template_params}> class TypedVariant{N} {{\n".format(
            N=N, template_params=",".join(["class V{i}, T l{i}".format(i=i) for i in range(N)]))
        )
        if N not in [2, 3, 6, 8]:
            out.write("static_assert(l0 != l1, \"Rerun the generation script and include this size enumeration\");\n")
            out.write("static_assert(l0 == l1, \"Rerun the generation script and include this size enumeration\");\n")
            out.write("};\n")
            continue

        # otherwise, generate the typed enum of size N

        # first ensure invariants give nice error messages
        for i, j in itertools.combinations(list(range(N)), 2):
            out.write("static_assert(!std::is_same_v<V{i}, V{j}>);\n".format(i=i, j=j))
            out.write("static_assert(!std::is_assignable_v<V{i}, V{j}>);\n".format(i=i, j=j))
            out.write("static_assert(l{i} != l{j});\n".format(i=i, j=j))

        out.write("private:\n struct Empty {};\n")
        out.write("union Variants {{ {vars}; Empty empty;\n".format(vars=";\n".join(["V{i} v{i}".format(i=i) for i in range(N)])))
        out.write("Variants() : empty{} {} \n ~Variants() { empty.~Empty(); } \n };\n")
        out.write("T m_type;\n Variants u;\n")

        out.write("void set_empty() {\n switch (m_type) {")
        for i in range(N):
            out.write("case l{i}: u.v{i}.~V{i}(); break;\n".format(i=i))
        out.write("}\n u.empty = Empty();\n }\n\n")

        out.write("void set_type_on_already_empty_struct(T type) {\n m_type = type; \n switch (m_type) {")
        for i in range(N):
            out.write("case l{i}: new (&u.v{i}) V{i}(); break;\n".format(i=i))
        out.write("}\n }\n\n")

        out.write("public:\n")
        out.write("void set_type(T type) { set_empty(); set_type_on_already_empty_struct(type); }\n")
        out.write("[[nodiscard]] T type() const { return m_type; }")

        out.write("TypedVariant{N}() : m_type{{l0}} {{ set_type_on_already_empty_struct(l0); }}\n".format(N=N))
        out.write("~TypedVariant{N}() {{ set_empty(); }}\n".format(N=N))

        out.write("TypedVariant{N}(TypedVariant{N} &&o) noexcept : m_type{{l0}} {{\n".format(N=N))
        out.write("set_type_on_already_empty_struct(o.type());\n switch (o.type()) {\n")
        for i in range(N):
            out.write("case l{i}: u_v{i}() = std::move(o.u_v{i}()); break;\n".format(i=i))
        out.write("}\n }")

        out.write("TypedVariant{N} &operator=(TypedVariant{N} &&o) noexcept {{\n".format(N=N))
        out.write("set_empty(); set_type_on_already_empty_struct(o.type());\n switch (o.type()) {\n")
        for i in range(N):
            out.write("case l{i}: u_v{i}() = std::move(o.u_v{i}()); break;\n".format(i=i))
        out.write("}\n return *this;\n }")

        out.write("TypedVariant{N}(const TypedVariant{N} &o) noexcept : m_type{{l0}} {{\n".format(N=N))
        for i in range(N):
            out.write("static_assert(std::is_copy_constructible_v<V{i}>);\n".format(i=i))
        out.write("set_type_on_already_empty_struct(o.type());\n switch (o.type()) {\n")
        for i in range(N):
            out.write("case l{i}: u_v{i}() = o.u_v{i}(); break;\n".format(i=i))
        out.write("}\n }")

        out.write("TypedVariant{N} &operator=(const TypedVariant{N} &o) noexcept {{\n".format(N=N))
        for i in range(N):
            out.write("static_assert(std::is_copy_constructible_v<V{i}>);\n".format(i=i))
        out.write("set_empty(); set_type_on_already_empty_struct(o.type());\n switch (o.type()) {\n")
        for i in range(N):
            out.write("case l{i}: u_v{i}() = o.u_v{i}(); break;\n".format(i=i))
        out.write("}\n return *this;\n }")

        for i in range(N):
            out.write("[[nodiscard]] V{i} &u_v{i}() {{ hassert(m_type == l{i}); return u.v{i}; }}\n".format(i=i))
            out.write("[[nodiscard]] const V{i} &u_v{i}() const {{ hassert(m_type == l{i}); return u.v{i}; }}\n".format(i=i))

            out.write("explicit TypedVariant{N}(const V{i}& v{i}) {{".format(N=N, i=i))
            out.write("set_type_on_already_empty_struct(l{i}); u_v{i}() = v{i}; }}".format(i=i))

            out.write("explicit TypedVariant{N}(V{i}&& v{i}) {{".format(N=N, i=i))
            out.write("set_type_on_already_empty_struct(l{i}); u_v{i}() = std::move(v{i}); }}".format(i=i))
        out.write("};\n\n")
    out.write("} // namespace ChpOptimize\n")

#os.system("(cd ../..; clang-format -style=file -i src/utils/typed-variants.h)")
os.system("clang-format -style=file -i typed-variants.h")
